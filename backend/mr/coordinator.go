package mr

import "log"
import "net"
import "os"
import "net/rpc"
import "net/http"
import "time"

type Phase int
type Status int

const (
    //Map Reduce Phases
    Map      Phase = 0
    Reduce   Phase = 1

    //Worker Statuses
    Running  Status = 0
    Done     Status = 1

    //TTL on Worker Tasks
    TaskTTL  time.Duration = time.Second * 10
)

type Task struct {
    Tid           int
    Phase         Phase
    File          string
	status		  Status
    M             int
    R             int
    Die           bool
}

type Coordinator struct {
    //# of intermediate files generated by Map
    M           int
    //# of output files, equal to nReduce
    R           int
    Phase       Phase
	tasks       []Task
    done        int
    doneCommand chan bool
    taskQueue   chan Task
    killCommand chan Task
	updateQueue chan UpdateTaskArgs
}

//Get new Task RPC, Grabs a new Task from the queue if there is any, otherwise tells worker to retry
func (c *Coordinator) GetTask(args *GetTaskArgs, task *Task) error {
    select {
        case t := <-c.taskQueue:
            go c.taskTTL(t.Tid, t.Phase)
            *task = t
        case t := <-c.killCommand:
            *task = t
        default:
            *task = Task{ Tid: -1, Die: false }
    }
    return nil
}

// Update Task RPC, only update if it's running and it's a job from the current Phase
func (c *Coordinator) UpdateTask(args *UpdateTaskArgs, reply *UpdateTaskReply) error {
	c.updateQueue <- *args
    return nil
}

func (c *Coordinator) taskTTL(tid int, phase Phase) {
    <-time.After(TaskTTL)
    c.updateQueue <-UpdateTaskArgs{
        Ok: false,
        Tid: tid,
        Phase: phase,
    }
}

func (c *Coordinator) taskUpdater() {
	for {
		args := <-c.updateQueue
		if c.tasks[args.Tid].status == Running && args.Phase == c.Phase{
			if args.Ok {
				//Finish task and set worker to Done
				c.done++
				c.tasks[args.Tid].status = Done
				//Init Reduce tasks
				if c.donePhase(Map){
					c.Phase = Reduce
					c.done = 0
					c.reduceTask()
				} else if c.donePhase(Reduce){
                    go func(){
                        for{
                            c.killCommand <-Task{ Die: true }
                        }
                    }()
                    go func(){
                        for{
                            c.doneCommand <-true
                        }
                    }()
                    return
				}
			} else {
				//Add Task back into queue
				c.taskQueue <- c.tasks[args.Tid]
			}
		}
	}
}

func (c *Coordinator) mapTask(files []string){
    for i, f := range files {
        task := Task{
            Tid:    i,
            status: Running,
            File:   f,
            Phase:  Map,
            M:      c.M,
            R:      c.R,
            Die:    false,
        }
        c.tasks[i] = task
        c.taskQueue <-task
    }
}

func (c *Coordinator) reduceTask(){
    for i := 0; i < c.R; i++ {
        task := Task{
            Tid:    i,
            status: Running,
            Phase:  Reduce,
            M:      c.M,
            R:      c.R,
            Die:    false,
        }
        c.tasks[i] = task
        c.taskQueue <-task
    }
}

// Checks if the current Phase is done
func (c *Coordinator) donePhase(phase Phase) bool{
    if phase == Map {
        return c.done == c.M && c.Phase == Map
    } else if phase == Reduce {
        return c.done == c.R && c.Phase == Reduce
    }
	return false
}

//
// start a thread that listens for RPCs from worker.go
//
func (c *Coordinator) server() {
    rpc.Register(c)
    rpc.HandleHTTP()
    //l, e := net.Listen("tcp", ":1234")
    sockname := coordinatorSock()
    os.Remove(sockname)
    l, e := net.Listen("unix", sockname)
    if e != nil {
        log.Fatal("listen error:", e)
    }
    go http.Serve(l, nil)
}

//
// main/mrcoordinator.go calls Done() periodically to find out
// if the entire job has finished.
//
func (c *Coordinator) Done() bool {
    select {
        case <-c.doneCommand:
            return true
        default:
            return false
    }
}

//
// create a Coordinator.
// main/mrcoordinator.go calls this function.
// nReduce is the number of reduce tasks to use.
//
func MakeCoordinator(files []string, nReduce int) *Coordinator {
    c := Coordinator{
        M:           len(files),
        R:           nReduce,
        Phase:       Map,
        done:        0,
        killCommand: make(chan Task),
        doneCommand: make(chan bool),
        updateQueue: make(chan UpdateTaskArgs),
    }
    var maxTasks int
    if len(files) > nReduce {
        maxTasks = len(files)
    } else {
        maxTasks = nReduce
    }
	c.tasks = make([]Task, maxTasks)
    c.taskQueue =  make(chan Task, maxTasks)
    //Add Map Tasks to Queue
    c.mapTask(files)
	//Spawn Task Updater
	go c.taskUpdater()
    //Spawn RPC server
    c.server()
    return &c
}
